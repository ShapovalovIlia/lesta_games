# Task_for_LestaStudio
---
## Задание №1

**Условие:**
> На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

Исходный код
```python
def is_even(value: int) -> bool:
      return value % 2 == 0
```
[+] Очевидное решение

[-] Работает медленнее

Мой вариант
```python
def is_even_fast(value: int) -> bool:
      return (value & 1) == 0
```
[+] Работает быстрее, т.к побитовые операции выполняются быстрее

[-] Нужно немного подумать, чтобы понять почему оно верное, можно закинуть объяснение в докстрингу

---

## Задание №2
**Условие**
> На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

В этом задании я представил два варианта реализации циклического буфера FIFO:
+ С помошью указателей на элементы по индексу
+ С помощью циклического сдвига списка

Оба варианта являются практически идентичными решениями, однако в первом не используются встроенные методы такие, как `pop`, `append` и т.д.

### Первая реализация
[+] Удаление и добавление элемента за О(1), так как используются указатели на первый и последний элементы.

[-] Используются логические операции для продвижения указателей при их совпадении.

### Вторая реализация

[+] Более понятный и лаканичный код, так как нет такого количества логических операци.

[-] Использование встроенных методов.

---

## Задание №3
**Условие**
>На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.

Я выбрал алгоритм сортировки heapsort, так как он гарантированно работает за O(n log n) операций. Объем используемой дополнительной памяти не зависит от размера массива и составляет O(1).

Среди недостатков данной сортировки можно отметить, что она неустойчива, а также то, что на уже отсортированных массивах она работает так же, как и на неотсортированных. Однако в задании не упоминалась необходимость устойчивости сортировки, поэтому это не стало определяющим фактором.

Я также рассматривал quicksort, timsort, bucketsort и radixsort.

Quicksort: avg O(nlogn) time complexity, worst case O(n^2); O(log(n)) space complexity, unstable

Timsort:  O(nlogn) time complexity; O(n) space complexity, stable

Radixsort: будет плохо работать для чисел с плавающей точкой

Bucketsort: будет хорошо работать только если диапазон чисел маленький. Допустим k - диапазон, тогда O(k) space complexity, O(n) time complexity


---
